using System;
using System.IO;
using System.Collections;
using System.Diagnostics;
using LibClang;

namespace Setup;

enum LibraryKind { Glfw, Vulkan }
static class Bindings
{
	public static Span<char8*> args;
	public static Clang.CXIndex index = Clang.CreateIndex(0, 0) ~ Clang.DisposeIndex(_);

	private static BumpAllocator vkFlagListAlloc = new .() ~ delete _;
	private static HashSet<String> vkFlagList = new:vkFlagListAlloc .();

	public static void File(char8* cHeader, StringView outPath, LibraryKind library)
	{
		let unit = Clang.ParseTranslationUnit(index, cHeader, args.Ptr, (.)args.Length, null, 0, .SkipFunctionBodies | .DetailedPreprocessingRecord);
		defer Clang.DisposeTranslationUnit(unit);

		StreamWriter outStream = scope .()..Create(outPath);
		outStream.WriteLine($"""
			/*  Generated by Setup/src/Bindings.bf
			 *  Do not edit manually!
			 */

			using System;
			using System.Interop;
			using Vulkan;

			namespace {library};

			static
			{{
			""");
		switch (library)
		{
		case .Glfw:
			outStream.Write("""
				public const String GLFWAPI =
			#if BF_PLATFORM_WINDOWS
					"glfw3.dll";
			#else
					"libgflw3.so";
			#endif
				\n
			""");
		case .Vulkan:
			outStream.Write("""
				public const CallingConventionAttribute.Kind VKAPI_CALL =
			#if BF_PLATFORM_WINDOWS
					.Stdcall;
			#else
					.Cdecl;
			#endif

				public struct VkBool32 : uint32
				{
					[Inline]
					public static operator bool(Self s) => s != VK_FALSE;

					[Inline]
					public static operator Self(bool b) => b ? VK_TRUE : VK_FALSE;
				}

				[Comptime(ConstEval=true)]
				public static uint32 VK_MAKE_API_VERSION(uint32 variant, uint32 major, uint32 minor, uint32 patch)
					=> (variant << 29U) | (major << 22U) | (minor << 12U) | (patch);

				[Comptime(ConstEval=true)]
				public static uint32 VK_MAKE_VIDEO_STD_VERSION(uint32 major, uint32 minor, uint32 patch)
					=> (major << 22) | (minor << 12) | (patch);
				\n
			""");
		}

		Clang.VisitChildren(Clang.GetTranslationUnitCursor(unit), (cursor, parent, data) =>
		{
			(StreamWriter outStream, StringView libraryStr, LibraryKind library) = *(.)data;

			mixin Str(Clang.CXString str)
			{
				defer:mixin Clang.DisposeString(str);
				StringView(Clang.GetCString(str))
			}

			let filename = Str!(Clang.GetFileName(Clang.GetSpellingLocation(Clang.GetCursorLocation(cursor), ..?, ?, ?, ?)));
			if (!filename.Contains(libraryStr, ignoreCase: true))
				return .Contine;

			static void Type(Clang.CXType type, String outString, LibraryKind library, bool outParam = false)
			{
				switch (type.kind)
				{
				case .CXType_Short: 			outString.Append("c_short");
				case .CXType_Int:   			outString.Append("c_int");
				case .CXType_Long:  			outString.Append("c_long");
				case .CXType_LongLong:			outString.Append("c_longlong");
				case .CXType_UShort: 			outString.Append("c_ushort");
				case .CXType_UInt:   			outString.Append("c_uint");
				case .CXType_ULong:  			outString.Append("c_ulong");
				case .CXType_ULongLong:			outString.Append("c_ulonglong");

				case .CXType_Char_S,
					 .CXType_SChar:				outString.Append("c_char");
				case .CXType_Char_U,
					 .CXType_UChar:				outString.Append("c_uchar");
				case .CXType_Void:				outString.Append("void");

				case .CXType_Bool: 				outString.Append("bool");
				case .CXType_Double,
					 .CXType_LongDouble: 		outString.Append("double");
				case .CXType_Float: 			outString.Append("float");

				case .CXType_LValueReference,
					 .CXType_RValueReference:	outString.Append("ref "); Type(Clang.GetPointeeType(type), outString, library);

				case .CXType_ConstantArray:		outString.AppendF($"{Type(Clang.GetArrayElementType(type), ..scope .(), library)}[{Clang.GetArraySize(type)}]");
				case .CXType_IncompleteArray:	outString.AppendF($"{Type(Clang.GetArrayElementType(type), ..scope .(), library)}*");

				case .CXType_FunctionNoProto:	outString.AppendF($"function {Type(Clang.GetResultType(type), .. scope .(), library)}()");
				case .CXType_FunctionProto:
					String parameters = scope .();
					for (let i < Clang.GetNumArgTypes(type))
					{
						Type(Clang.GetArgType(type, i), parameters, library);
						//TODO: parameter names
						parameters.Append(", ");
					}	
					if (parameters.EndsWith(", ")) parameters.RemoveFromEnd(2);

					outString.AppendF($"function {Type(Clang.GetResultType(type), ..scope .(), library)}({parameters})");

				case .CXType_Typedef, .CXType_Elaborated:
					var name = Str!(Clang.GetTypeSpelling(type));
					if (name.StartsWith("const "))	name.RemoveFromStart("const ".Length);
					if (name.StartsWith("struct "))	name.RemoveFromStart("struct ".Length);
					if (name.StartsWith("union "))	name.RemoveFromStart("union ".Length);
					if (name.StartsWith("enum "))	name.RemoveFromStart("enum ".Length);

					switch (name)
					{
					case "int8_t": outString.Append("int8");
					case "int16_t": outString.Append("int16");
					case "int32_t": outString.Append("int32");
					case "int64_t": outString.Append("int64");
					case "uint8_t": outString.Append("uint8");
					case "uint16_t": outString.Append("uint16");
					case "uint32_t": outString.Append("uint32");
					case "uint64_t": outString.Append("uint64");
					case "size_t": outString.Append("c_size");
					default: outString.Append(name);
					}

				case .CXType_Pointer:
					let pointeeType = Clang.GetPointeeType(type);
					if (outParam && (library case .Glfw || (pointeeType.kind case .CXType_Elaborated && Clang.IsConstQualifiedType(pointeeType) == 0)))
						{ outString.Append("out "); Type(pointeeType, outString, library); break; }
					Type(pointeeType, outString, library);
					if (pointeeType.kind != .CXType_FunctionNoProto && pointeeType.kind != .CXType_FunctionProto)
						outString.Append('*');
				default:
					Runtime.FatalError();
				}
			}

			mixin SrcStr(Clang.CXString str)
			{
				String s = scope:mixin .();
				Compiler.Identifier.GetSourceName(.(Clang.GetCString(str)), s);
				Clang.DisposeString(str);
				s
			}

			static bool WriteDoc(Clang.CXCursor cursor, StreamWriter outStream, String outParams = null)
			{
				let documentation = Str!(Clang.Cursor_GetRawCommentText(cursor));
				for (var line in documentation.Split('\n', .RemoveEmptyEntries))
				{
					outStream.Write("\t");
					if (line.StartsWith("/*!"))
					{
						outStream.Write("/**");
						line.RemoveFromStart(3);
					}
					if (line.Contains("@param[out]") && outParams != null)
						outParams.Append(line);
					outStream.WriteLine(line);
				}
				return !documentation.IsEmpty;
			}

			let spelling = SrcStr!(Clang.GetCursorSpelling(cursor));
			switch (cursor.kind)
			{
			case .CXCursor_FunctionDecl:
				let outParams = WriteDoc(cursor, outStream, ..scope .());
				switch (library)
				{
				case .Glfw: outStream.WriteLine("\t[Import(GLFWAPI), CLink]");
				case .Vulkan: outStream.WriteLine("\t[CallingConvention(VKAPI_CALL), CLink]");
				}

				outStream..Write("\tpublic static extern ")
						 ..Write(Type(Clang.GetCursorResultType(cursor), ..scope .(), library))
						 ..Write($" {spelling}(");
				let numArgs = Clang.Cursor_GetNumArguments(cursor);
				bool wasSizeOut = false;
				for (let i < numArgs)
				{
					let param = Clang.Cursor_GetArgument(cursor, (.)i);
					let name = SrcStr!(Clang.GetCursorSpelling(param));
					bool outParamPossible;
					switch (library)
					{
					case .Glfw: outParamPossible = outParams.Contains(scope $"@param[out] {name} ");
					case .Vulkan: outParamPossible = !(i+1 == numArgs && wasSizeOut);
					}
					String type = scope .();
					outStream.Write(Type(Clang.GetCursorType(param), ..type, library, outParamPossible));
					wasSizeOut = type == "out uint32";
					if (!name.IsEmpty)
						outStream..Write(" ")..Write(name);
					if (i+1 < numArgs)
						outStream.Write(", ");
				}
				outStream.WriteLine(");");
			case .CXCursor_TypedefDecl:
				let type = Clang.GetTypedefDeclUnderlyingType(cursor);
				let typeSrc = Type(type, ..scope .(), library);
				if (type.kind case .CXType_Elaborated) do
				{
					let typeSpelling = Str!(Clang.GetTypeSpelling(type));
					if (spelling == "VkBool32" ||
						typeSpelling.StartsWith("struct") ||
						typeSpelling.StartsWith("enum") ||
						typeSpelling.StartsWith("union"))
							return .Contine;
					if (library != .Vulkan && typeSpelling == "VkFlags") break;
					let flagBits = scope String(spelling)..Replace("Flags", "FlagBits");
					if (vkFlagList.Contains(flagBits))
						typeSrc.Set(flagBits);
				}
				if (typeSrc.StartsWith("function "))
				{
					WriteDoc(cursor, outStream);
					if (library case .Vulkan)
						outStream.WriteLine("\t[CallingConvention(VKAPI_CALL)]");
					outStream.Write("\tpublic ");
					let parenIdx = typeSrc.IndexOf('(');
					typeSrc..Insert(parenIdx, spelling)..Insert(parenIdx, ' ');
					outStream..Write(typeSrc)..Write(";\n\n");
					return .Contine;
				}
				WriteDoc(cursor, outStream);
				outStream.Write($"\tpublic typealias {spelling} = {typeSrc};\n");
			case .CXCursor_StructDecl, .CXCursor_UnionDecl:
				WriteDoc(cursor, outStream);
				if (library case .Vulkan && spelling.EndsWith("_T"))
				{
					outStream.WriteLine($"\tpublic struct {spelling};");
					return .Contine;
				}

				outStream.Write($"\t[CRepr{_ case .CXCursor_UnionDecl ? (", Union") : ("")}]\n\tpublic struct {spelling}\n\t{{\n");
				Clang.VisitChildren(cursor, (cursor, parent, data) =>
				{
					if (cursor.kind != .CXCursor_FieldDecl)
						Runtime.FatalError();

					(StreamWriter outStream, LibraryKind library) = *(.)data;
					outStream.Write("\t");
					let hasDoc = WriteDoc(cursor, outStream);
					if (hasDoc) outStream.Write("\t");
					outStream.WriteLine($"\tpublic {Type(Clang.GetCursorType(cursor), ..scope .(), library)} {SrcStr!(Clang.GetCursorSpelling(cursor))};");
					if (hasDoc) outStream.WriteLine();
					return .Contine;
				}, &(outStream, library));
#unwarn
				outStream.Write("\t}\n");
			case .CXCursor_EnumDecl:
				if (library case .Vulkan && spelling.Contains("FlagBits"))
					vkFlagList.Add(new:vkFlagListAlloc .(spelling));
				WriteDoc(cursor, outStream);
				outStream.Write($"\t[CRepr, AllowDuplicates]\n\tpublic enum {spelling} : {Type(Clang.GetEnumDeclIntegerType(cursor), ..scope .(), library)}\n\t{{\n");
				Clang.VisitChildren(cursor, (cursor, parent, data) =>
				{
					if (cursor.kind != .CXCursor_EnumConstantDecl)
						Runtime.FatalError();
	
					(StreamWriter outStream, LibraryKind library) = *(.)data;
					outStream.Write("\t");
					let hasDoc = WriteDoc(cursor, outStream);
					if (hasDoc) outStream.Write("\t");
					outStream.WriteLine($"\t{SrcStr!(Clang.GetCursorSpelling(cursor))} = {Clang.GetEnumConstantDeclValue(cursor)},");
					if (hasDoc) outStream.WriteLine();
					return .Contine;
				}, &(outStream, library));
#unwarn
				outStream.Write("\t}\n");
			case .CXCursor_MacroDefinition:
				const StringView[?] blacklist = .("APIENTRY", "GLAPIENTRY", "WINGDIAPI", "CALLBACK", "VKAPI_CALL", "VKAPI_PTR", "VULKAN_H_", "VULKAN_CORE_H_");
				if (blacklist.Contains(spelling) || Clang.Cursor_IsMacroFunctionLike(cursor) != 0)
					return .Contine;

				let unit = Clang.Cursor_GetTranslationUnit(cursor);
				Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), let tokens, let tokenCount);
				defer Clang.DisposeTokens(unit, tokens, tokenCount);
				if (tokenCount < 2) return .Contine;
				WriteDoc(cursor, outStream);
				String value = scope .();
				for (uint32 i = 1; i < tokenCount; i++)
					value.Append(Str!(Clang.GetTokenSpelling(unit, tokens[i])));
				outStream.Write("\tpublic const ");
				if (value.StartsWith('"') || value.EndsWith("_EXTENSION_NAME"))
					outStream.Write("c_char*");
				else if (value.Contains("ULL"))
				{
					outStream.Write("c_ulonglong");
					value.Replace("LL", "");
				}
				else if (value.Contains("(void*)"))
					outStream.Write("void*");
				else if (value.EndsWith("F", .OrdinalIgnoreCase))
					outStream.Write("float");
				else switch (library)
				{
				case .Vulkan:
					outStream.Write("c_uint");
					value.Replace("U)", ")");
					if (value.EndsWith('U'))
						value.RemoveFromEnd(1);
				case .Glfw:
					outStream.Write("c_int");
					if (spelling == "GLFW_ANY_POSITION")
						value.Insert(0, "(.)");
				}
				outStream.Write($" {spelling} = {value};\n");
			default:
				return .Contine;
			}

			outStream.WriteLine();
			return .Contine;
		}, &(outStream, StringView(library.ToString(..scope .())), library));

		outStream.WriteLine("}");
	}
}